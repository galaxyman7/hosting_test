<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LAN P2P Chat (Short Codes) + Hex Board</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 0; padding: 16px; }
  h1 { font-size: 1.3rem; margin-bottom: 8px; }
  h2 { font-size: 1.1rem; margin: 16px 0 8px; }
  button { padding: 6px 10px; margin: 4px; border-radius: 6px; cursor: pointer; }
  textarea { width: 100%; min-height: 70px; margin-top: 6px; }
  .panel { border: 1px solid #8884; border-radius: 8px; padding: 12px; margin-top: 12px; }
  .peer-card { border: 1px solid #8884; border-radius: 8px; padding: 10px; margin-top: 10px; }
  #chat { height: 180px; overflow: auto; border: 1px solid #8884; border-radius: 8px; padding: 8px; background: #f8f8f8; }
  .msg { margin: 4px 0; }
  .me { font-weight: bold; }

  /* Board styles */
  #boardPanel { display:none; }
  #boardContainer { overflow: auto; border: 1px solid #8884; border-radius: 8px; padding: 8px; background: #fafafa; }
  svg { max-width: 100%; height: auto; }
  .hex { fill: #eaeaea; stroke: #bbb; stroke-width: 1; }
  .edge { stroke: #666; stroke-width: 2; cursor: pointer; }
  .edge.bold { stroke: #000; stroke-width: 4; }
  .edge:hover { stroke: #333; }
</style>
</head>
<body>

<h1>LAN P2P Chat (Short Codes)</h1>
<div>
  <button id="hostBtn">Host</button>
  <button id="playerBtn">Player</button>
</div>

<div id="hostPanel" class="panel" style="display:none;">
  <h2>Host controls</h2>
  <button id="newOfferBtn">Create offer for new player</button>
  <div id="hostPeers"></div>
</div>

<div id="playerPanel" class="panel" style="display:none;">
  <h2>Player join</h2>
  <label>Paste host offer code:</label>
  <textarea id="offerInput"></textarea>
  <button id="createAnswerBtn">Create my answer</button>
  <label>Your answer code (copy this to host):</label>
  <textarea id="answerOutput" readonly></textarea>
  <button id="copyAnswerBtn">Copy Answer</button>
  <button id="finalizeBtn" disabled>Finalize connection</button>
  <div id="playerStatus">Not connected.</div>
</div>

<div id="chatPanel" class="panel" style="display:none;">
  <h2>Group chat</h2>
  <div id="chat"></div>
  <input id="chatInput" type="text" placeholder="Type a message..." />
  <button id="sendBtn" disabled>Send</button>
</div>

<div id="boardPanel" class="panel">
  <h2>Hex board (side length 6)</h2>
  <div id="boardContainer">
    <svg id="hexBoard" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
</div>

<!-- Compression library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

<script>
/* ---------------------------
   Signaling compression
---------------------------- */
function compressSDP(desc) {
  const sdp = desc.sdp;
  const compressed = pako.deflate(sdp);
  return btoa(String.fromCharCode(...compressed))
    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
function decompressSDP(code, type) {
  code = code.replace(/-/g, '+').replace(/_/g, '/');
  const bin = atob(code);
  const arr = Uint8Array.from(bin, c => c.charCodeAt(0));
  const sdp = pako.inflate(arr, { to: 'string' });
  return { type, sdp };
}
function waitForIceGathering(pc) {
  return new Promise(resolve => {
    if (pc.iceGatheringState === 'complete') return resolve();
    pc.addEventListener('icegatheringstatechange', () => {
      if (pc.iceGatheringState === 'complete') resolve();
    });
    setTimeout(resolve, 3000);
  });
}

/* ---------------------------
   Chat + P2P plumbing
---------------------------- */
const peers = new Map(); // id -> { pc, dc }
const chatEl = document.getElementById('chat');
const sendBtn = document.getElementById('sendBtn');
const chatInput = document.getElementById('chatInput');
let isHost = false;

function addChatMessage(sender, text) {
  const div = document.createElement('div');
  div.className = 'msg';
  div.innerHTML = `<span class="${sender === 'Me' ? 'me' : ''}">${sender}:</span> ${text}`;
  chatEl.appendChild(div);
  chatEl.scrollTop = chatEl.scrollHeight;
}
function broadcast(payload) {
  const msg = typeof payload === 'string'
    ? { type: 'chat', text: payload }
    : payload;
  for (const { dc } of peers.values()) {
    if (dc && dc.readyState === 'open') {
      dc.send(JSON.stringify(msg));
    }
  }
}

document.getElementById('hostBtn').onclick = () => {
  isHost = true;
  document.getElementById('hostPanel').style.display = '';
  document.getElementById('playerPanel').style.display = 'none';
  document.getElementById('chatPanel').style.display = '';
  document.getElementById('boardPanel').style.display = '';
};
document.getElementById('playerBtn').onclick = () => {
  isHost = false;
  document.getElementById('playerPanel').style.display = '';
  document.getElementById('hostPanel').style.display = 'none';
  document.getElementById('chatPanel').style.display = '';
  document.getElementById('boardPanel').style.display = '';
};

sendBtn.onclick = () => {
  const text = chatInput.value.trim();
  if (!text) return;
  addChatMessage('Me', text);
  broadcast(text);
  chatInput.value = '';
};

document.getElementById('newOfferBtn').onclick = async () => {
  const id = 'p' + Math.random().toString(36).slice(2, 8);
  const pc = new RTCPeerConnection({ iceServers: [] });
  const dc = pc.createDataChannel('chat');
  dc.onopen = () => sendBtn.disabled = false;
  dc.onmessage = ev => handleIncoming(JSON.parse(ev.data), id);

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  await waitForIceGathering(pc);
  const code = compressSDP(pc.localDescription);

  const card = document.createElement('div');
  card.className = 'peer-card';
  card.innerHTML = `
    <strong>Player ${id}</strong><br>
    Offer code:<br>
    <textarea readonly>${code}</textarea><br>
    <button id="copyOffer_${id}">Copy Offer</button><br>
    Paste Answer:<br>
    <textarea id="answer_${id}"></textarea><br>
    <button id="accept_${id}">Accept Answer</button>
    <div id="status_${id}">Waitingâ€¦</div>
  `;
  card.querySelector(`#copyOffer_${id}`).onclick = () => {
    navigator.clipboard.writeText(code);
    alert('Offer copied!');
  };
  card.querySelector(`#accept_${id}`).onclick = async () => {
    const ansText = card.querySelector(`#answer_${id}`).value.trim();
    if (!ansText) return;
    const answerObj = decompressSDP(ansText, "answer");
    await pc.setRemoteDescription(answerObj);
    card.querySelector(`#status_${id}`).textContent = 'Connected!';
    // Push current board state to the newly connected peer
    syncFullBoardToPeer(dc);
  };
  document.getElementById('hostPeers').appendChild(card);
  peers.set(id, { pc, dc });
};

document.getElementById('createAnswerBtn').onclick = async () => {
  const offerText = document.getElementById('offerInput').value.trim();
  if (!offerText) return alert('Paste host offer code first.');
  const offerObj = decompressSDP(offerText, "offer");
  const pc = new RTCPeerConnection({ iceServers: [] });
  pc.ondatachannel = ev => {
    const dc = ev.channel;
    peers.set('Host', { pc, dc });
    dc.onopen = () => {
      document.getElementById('playerStatus').textContent = 'Connected!';
      sendBtn.disabled = false;
      // Request a full board sync from host
      dc.send(JSON.stringify({ type: 'board-request-sync' }));
    };
    dc.onmessage = ev => handleIncoming(JSON.parse(ev.data), 'Host');
  };
  await pc.setRemoteDescription(offerObj);
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  await waitForIceGathering(pc);
  const code = compressSDP(pc.localDescription);
  document.getElementById('answerOutput').value = code;
  document.getElementById('copyAnswerBtn').onclick = () => {
    navigator.clipboard.writeText(code);
    alert('Answer copied!');
  };
  document.getElementById('finalizeBtn').disabled = false;
};

/* ---------------------------
   Hex board
   - Axial coordinates, radius r = s - 1
   - s = 6 => r = 5
---------------------------- */
const BOARD_SIDE = 6;
const RADIUS = BOARD_SIDE - 1; // 5
const HEX_SIZE = 24; // pixel radius from center to any corner
const BOARD_MARGIN = 20; // extra padding in SVG
const hexBoard = document.getElementById('hexBoard');
const boldEdges = new Set(); // keys like "q,r,e" where e in [0..5]
const edgeEls = new Map();   // key -> SVG line element

function axialToPixel(q, r) {
  // Pointy-top axial (q, r)
  const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
  const y = HEX_SIZE * (3/2 * r);
  return { x, y };
}
function hexCorners(q, r) {
  const center = axialToPixel(q, r);
  const angles = [30, 90, 150, 210, 270, 330]; // pointy-top
  const pts = angles.map(a => {
    const rad = Math.PI * a / 180;
    return {
      x: center.x + HEX_SIZE * Math.cos(rad),
      y: center.y + HEX_SIZE * Math.sin(rad)
    };
  });
  return pts; // [corner0..corner5], edges are between consecutive corners
}
function eachHexCoord(fn) {
  // |q|, |r|, |q + r| <= RADIUS
  for (let q = -RADIUS; q <= RADIUS; q++) {
    for (let r = -RADIUS; r <= RADIUS; r++) {
      const s = -q - r;
      if (Math.max(Math.abs(q), Math.abs(r), Math.abs(s)) <= RADIUS) {
        fn(q, r);
      }
    }
  }
}

function buildBoard() {
  // Compute bounds
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  const centers = [];
  eachHexCoord((q, r) => {
    const c = axialToPixel(q, r);
    centers.push({ q, r, ...c });
    minX = Math.min(minX, c.x - HEX_SIZE - 2);
    maxX = Math.max(maxX, c.x + HEX_SIZE + 2);
    minY = Math.min(minY, c.y - HEX_SIZE - 2);
    maxY = Math.max(maxY, c.y + HEX_SIZE + 2);
  });

  const width = (maxX - minX) + BOARD_MARGIN * 2;
  const height = (maxY - minY) + BOARD_MARGIN * 2;
  hexBoard.setAttribute('viewBox', `${minX - BOARD_MARGIN} ${minY - BOARD_MARGIN} ${width} ${height}`);

  // Draw tiles
  const tileGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  tileGroup.setAttribute('id', 'tiles');
  hexBoard.appendChild(tileGroup);

  // Draw edges
  const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  edgeGroup.setAttribute('id', 'edges');
  hexBoard.appendChild(edgeGroup);

  eachHexCoord((q, r) => {
    // Tile polygon
    const corners = hexCorners(q, r);
    const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    poly.setAttribute('class', 'hex');
    poly.setAttribute('points', corners.map(p => `${p.x},${p.y}`).join(' '));
    tileGroup.appendChild(poly);

    // Six edges (0..5) between corners[i] -> corners[(i+1)%6]
    for (let e = 0; e < 6; e++) {
      const a = corners[e];
      const b = corners[(e + 1) % 6];
      const key = `${q},${r},${e}`;
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', a.x);
      line.setAttribute('y1', a.y);
      line.setAttribute('x2', b.x);
      line.setAttribute('y2', b.y);
      line.setAttribute('class', 'edge');
      line.dataset.key = key;

      // Click handler for host only
      line.addEventListener('click', () => {
        if (!isHost) return;
        toggleEdgeBold(key, true); // local toggle and broadcast
      });

      edgeGroup.appendChild(line);
      edgeEls.set(key, line);
    }
  });
}

function toggleEdgeBold(key, shouldBroadcast) {
  // Toggle local state
  if (boldEdges.has(key)) {
    boldEdges.delete(key);
  } else {
    boldEdges.add(key);
  }
  // Update SVG class
  const el = edgeEls.get(key);
  if (el) {
    if (boldEdges.has(key)) el.classList.add('bold');
    else el.classList.remove('bold');
  }
  // Broadcast to peers
  if (shouldBroadcast) {
    broadcast({ type: 'board-edge', key, on: boldEdges.has(key) });
  }
}

function applyEdgeRemote(key, on) {
  // Force a specific state from remote
  const el = edgeEls.get(key);
  if (!el) return;
  if (on) boldEdges.add(key); else boldEdges.delete(key);
  if (on) el.classList.add('bold'); else el.classList.remove('bold');
}

function fullBoardSnapshot() {
  return Array.from(boldEdges).map(k => ({ key: k, on: true }));
}

function syncFullBoardToPeer(dc) {
  if (!dc || dc.readyState !== 'open') return;
  dc.send(JSON.stringify({ type: 'board-sync', edges: fullBoardSnapshot() }));
}

/* ---------------------------
   Incoming message handler
---------------------------- */
function handleIncoming(msg, senderLabel) {
  if (msg.type === 'chat') {
    addChatMessage(senderLabel, msg.text);
    return;
  }
  if (msg.type === 'board-edge') {
    applyEdgeRemote(msg.key, msg.on);
    return;
  }
  if (msg.type === 'board-sync') {
    // Apply full snapshot
    (msg.edges || []).forEach(({ key, on }) => applyEdgeRemote(key, on));
    return;
  }
  if (msg.type === 'board-request-sync') {
    // Host responds with current state
    // Find the sender's datachannel to reply directly if needed,
    // but broadcasting works fine for all (idempotent)
    if (isHost) broadcast({ type: 'board-sync', edges: fullBoardSnapshot() });
    return;
  }
}

/* ---------------------------
   Init board at load
---------------------------- */
buildBoard();
</script>
</body>
</html>